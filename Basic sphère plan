import matplotlib.pyplot as plt
import numpy as np
import matplotlib.animation as anim
from mpl_toolkits.mplot3d import *



class SPHERE :        # pour faire une sphère
     def __init__(self,x,y,z,radius):
        self.x=x
        self.y=y
        self.z=z
        self.r=radius

class PLAN :   # pour faire un plan incliné
    def __init__(self,x,y,z,u,v,w):

# point du plan
        self.x=x
        self.y=y
        self.z=z

# vecteur normal du plan
        self.u=u
        self.v=v
        self.w=w

#pour l'équation de plan
#d= -plan.u*plan.x-plan.v*plan.y-plan.w*plan.z


######## le plot

Ω=[
[SPHERE(0,0,1,1)],   #spheres
[PLAN(0,0,0,0,0,1)]  #plans
]

A = np.linspace(0, 2 * np.pi, 100)
B = np.linspace(0, np.pi, 100)
X = 10 * np.outer(np.cos(A), np.sin(B))
Y = 10 * np.outer(np.sin(A), np.sin(B))
Z = 10 * np.outer(np.ones(np.size(A)), np.cos(B))

fig = plt.figure()
ax = fig.add_subplot(projection='3d')

S=[ax.plot_surface(i.r*X+i.x, i.r*Y+i.y, i.r*Z+i.z, color='b') for i in Ω[0]]
# for i in Ω[1]:
#     d= -i.u*i.x-i.v*i.y-i.w*i.z
#     ax.contourf([50,50,-50,-50],[50,-50,50,-50],[(-d-i.u*50-i.v*50)/i.w,(-d-i.u*50-i.v*-50)/i.w,(-d-i.u*-50-i.v*50)/i.w,(-d-i.u*-50-i.v*-50)/i.w])

######## début code


def contact(plan,sph):
    d=-plan.u*plan.x-plan.v*plan.y-plan.w*plan.z
    if (abs(sph.x*plan.u+sph.y*plan.v+sph.z*plan.w+d)/np.sqrt(np.power(plan.u,2)+np.power(plan.v,2)+np.power(plan.w,2))<=sph.r):
        return True
    return False

def animation(k):
    l=0
    for i in Ω[0]:
        for j in Ω[1]:
            if contact(j,i):
                i.x+=j.u
                i.y+=j.v
                i.z+=j.w+10
        i.z+=-1
        S[l].X=i.r*X+i.x
        S[l].Y=i.r*Y+i.y
        S[l].Z=i.r*Z+i.z
        l+=1
    return S

ani = anim.FuncAnimation(fig=fig, func=animation, frames=range(1000), interval=100, blit=True)
ani.save(filename='basicSpherePlan',writer=None)
plt.show()
